regressionLine Camera::twoPointRegression(int color, int side) {
    
    IplImage *thresholded;
    squares_t *squares;

    int width;
    int squareCount = 0;
    
    regressionLine result;

    switch (color) {
    case COLOR_PINK:
        thresholded = _pinkThresholded;
        squares = _pinkSquares;
        break;
    case COLOR_YELLOW:
        thresholded = _yellowThresholded;
        squares = _yellowSquares;
        break;
    }

    int center = thresholded->width / 2;

    LOG.printfScreen(LOG_HIGH, "regression","center: %d\n",center);
    
    squares_t *curSquare = squares;
    squares_t *largest;
    squares_t *secondLargest;
    while (curSquare != NULL) {
	switch (side) {
	    case SIDE_LEFT:	
        	if (curSquare->center.x < center) {	
			LOG.printfScreen(LOG_HIGH, "regression","Left square: x: %d y:%d area: %d\n",curSquare->center.x, curSquare->center.y, curSquare->area);
			squareCount++;
		}
		break;
	    case SIDE_RIGHT:
		if (curSquare->center.x > center) {
			squareCount++;
			LOG.printfScreen(LOG_HIGH, "regression","Right square: x: %d y:%d area: %d\n",curSquare->center.x, curSquare->center.y, curSquare->area);
		}
		break;
	    }
        curSquare = curSquare->next;
    }

    result.numSquares = squareCount;
    
    if(squareCount >= 2) { 

        //Linear regression algorithm
        //Ref: http://mathworld.wolfram.com/LeastSquaresFitting.html
        curSquare = squares;
        while (curSquare != NULL) {
	    switch (side) {
	        case SIDE_LEFT:	
        	    if (curSquare->center.x < center) {
	    		xAvg += curSquare->center.x;
	    		yAvg += curSquare->center.y;
	    		xSqSum += curSquare->center.x * curSquare->center.x;
	    		xySum += curSquare->center.x * curSquare->center.y;
		    } 
		    break;
	        case SIDE_RIGHT:
		    if (curSquare->center.x > center) {
	    		xAvg += curSquare->center.x;
	    		yAvg += curSquare->center.y;
	    		xSqSum += curSquare->center.x * curSquare->center.x;
	    		xySum += curSquare->center.x * curSquare->center.y;
		    } 
		    break;
	    }
	    curSquare = curSquare->next;
        }   

        xAvg /= result.numSquares;
        yAvg /= result.numSquares;

	float ssxx = 0;
	float ssyy = 0;
	float ssxy = 0;
        curSquare = squares;
        while (curSquare != NULL) {
	    switch (side) {
	        case SIDE_LEFT:	
        	    if (curSquare->center.x < center) {
	    		ssxx += (curSquare->center.x - xAvg) * (curSquare->center.x - xAvg);
			ssyy += (curSquare->center.y - yAvg) * (curSquare->center.y - yAvg);
			ssxy += (curSquare->center.x - xAvg) * (curSquare->center.y - yAvg);
		    } 
		    break;
	        case SIDE_RIGHT:
		    if (curSquare->center.x > center) {
	    		ssxx += (curSquare->center.x - xAvg) * (curSquare->center.x - xAvg);
			ssyy += (curSquare->center.y - yAvg) * (curSquare->center.y - yAvg);
			ssxy += (curSquare->center.x - xAvg) * (curSquare->center.y - yAvg);
		    } 
		    break;
	    }
	    curSquare = curSquare->next;
	}

	
    	LOG.printfScreen(LOG_HIGH, "regression", "%d Equation: Y = %f*X + %f\n", side, ssxy/ssxx, (yAvg-((ssxy/ssxx)*xAvg)));
	
        result.intercept = (((yAvg * xSqSum) - (xAvg * xySum) ) / (xSqSum - (result.numSquares * xAvg * xAvg)));
        result.slope = ((xySum - (result.numSquares * xAvg * yAvg)) / (xSqSum - (result.numSquares * xAvg * xAvg)));
    
    } else { //We don't perform an extrapolation if there aren't enough squares
        result.intercept = -999; //Some sort of error flag value, though we can also just check the numSquares value
	result.slope = -999;
    }

    return result;
}


/**
  * Calculates the slope and y intercept of
  * the given squares, based on their X and Y pixel centers of mass
  *
  * Also gives an r2 calculation, which shows how accuratly the line
  * represents the points, with a value of 0 meaning none, to 1 meaning
  * the line hits all the points
  * 
  * @arg line - pass in a pointer to the lineStruct that will receive the value for the line
**/

void Camera::calculateSlope(squares_t *squares, lineStruct *line){
	squares_t *currSqr = squares;
	float xAvg, yAvg;
	float sumx = 0, sumy=0, sumxy=0;
	int count=0;
	// calculate average x and y values
	while(currSqr != NULL){
		sumx+=(float) currSqr->center.x;
		sumy+=(float) currSqr->center.y;
		count++;
		currSqr=currSqr->next;
	}
	xAvg = sumx/count;
	yAvg = sumy/count;

	if(count <= 1){
		// either 1 or 0 squares, cannot find a line with one point

		line->slope = -999.0;
		line->yInt = -999.0;
		line->r2 = -999.0;
		return ;
	}

	//calculate Sx, Sy, Sxy
	sumx=0; sumy=0;
	currSqr=squares;
	while(currSqr != NULL){
		LOG.printfScreen(LOG_HIGH, "camera image", "i'm here\n");
		sumx+=(currSqr->center.x - xAvg)*(currSqr->center.x - xAvg);
		sumy+=(currSqr->center.y - yAvg)*(currSqr->center.y - yAvg);
		sumxy+=(currSqr->center.x - xAvg)*(currSqr->center.y - yAvg);
		currSqr=currSqr->next;
	}

	line->slope = sumxy/sumx;
	line->yInt = yAvg - line->slope*xAvg;
	line->r2 = sumxy/sqrt(sumx*sumy);
}

/**
 * @return the location of the robot in the grid based on a scale of -1..0..1
 * 		with -1 being farthest left in the grid, 0 being centered, and 1 being farthest right
 */
float Camera::estimatePos (squares_t *leftSquares, squares_t *rightSquares){
	//find the lines for both squares
	lineStruct leftLine;
	lineStruct rightLine;
	
	calculateSlope(leftSquares, &leftLine);
	calculateSlope(rightSquares, &rightLine);
	
	//check if slopes could not be calculated
	if (leftLine.slope == -999.0){
		LOG.printfScreen(LOG_HIGH, "camera image", "Error while calculating slope of left line... cannot estimate position accurately\n");
	}
	if (rightLine.slope == -999.0){
		LOG.printfScreen(LOG_HIGH, "camera image", "Error while calculating slope of right line... cannot estimate position accurately\n");
	}
	
	LOG.printfScreen(LOG_HIGH, "camera image", "Left line: y = %f*x + %f\t\tr^2 = %f\n", leftLine.slope, leftLine.yInt, leftLine.r2);
	LOG.printfScreen(LOG_HIGH, "camera image", "Right line: y = %f*x + %f\t\tr^2 = %f\n", rightLine.slope, rightLine.yInt, rightLine.r2);

	return 0;
}

float Camera::findPos (squares_t *squares){
	
    int center = _pinkThresholded->width / 2;
	
	
	squares_t *rightSquares=NULL;
	squares_t *indexRS=NULL;
	
	squares_t *leftSquares = NULL;
	squares_t *indexLS = NULL;
	
    squares_t *curSquare = squares;
	int cnt = 0;
	int count = 0;
    while (curSquare != NULL) {
        if (curSquare->center.x > center) {
			if(rightSquares == NULL){
				rightSquares = new squares_t;
				indexRS = rightSquares;
				rightSquares->next = NULL;
			}
			else{
				indexRS->next = new squares_t;
				indexRS = indexRS->next;
				indexRS = curSquare;
				indexRS->next = NULL;
			}
			count++;
        }
        else {
			if(leftSquares == NULL){
				leftSquares = new squares_t;
				indexLS = leftSquares;
				leftSquares->next = NULL;
			}
			else{
				indexLS->next = new squares_t;
				indexLS = indexLS->next;
				indexLS = curSquare;
				indexLS->next = NULL;
			}
			cnt++;
		}
        curSquare = curSquare->next;
		printf("i'm here again\n");
    }
    LOG.printfScreen(LOG_HIGH, "camera image", "counts: right = %d, left = %d\n", count, cnt);
    float result = estimatePos(leftSquares, rightSquares);
	
	//clean up old arrays
	indexRS = rightSquares;
	while (indexRS != NULL){
		squares_t *nextPointer = indexRS->next;
		delete indexRS;
		indexRS = nextPointer;
	}
	indexLS = leftSquares;
	while (indexLS != NULL){
		squares_t *nextPointer = indexLS->next;
		delete indexRS;
		indexLS = nextPointer;
	}

	return result;
}

//sort squares based on size
void sortSquaresSize(squares_t * sqr, std::vector<squares_t> * vec){
	squares_t * currSqr = sqr;
	while(currSqr != NULL) {
		vec->push_back(*currSqr);
	}
	for(int i=0; i<vec->size(); i++){
		for(int j=i; j<vec->size();j++){
			if((*vec)[j].area > (*vec)[i].area){
				squares_t temp = (*vec)[i];
				vec[i] = vec[j];
				vec[j] = vec[i];
			}
		}
	}
}
//sort squares based on x
void sortSquaresX(squares_t * sqr, std::vector<squares_t> * vec){
	squares_t * currSqr = sqr;
	while(currSqr != NULL) {
		vec->push_back(*currSqr);
	}
	for(int i=0; i<vec->size(); i++){
		for(int j=i; j<vec->size();j++){
			if((*vec)[j].center.x > (*vec)[i].center.x){
				squares_t temp = (*vec)[i];
				(*vec)[i] = (*vec)[j];
				(*vec)[j] = (*vec)[i];
			}
		}
	}
}
//sort squares based on y
void sortSquaresY(squares_t * sqr, std::vector<squares_t> * vec){
	squares_t * currSqr = sqr;
	while(currSqr != NULL) {
		vec->push_back(*currSqr);
	}
	for(int i=0; i<vec->size(); i++){
		for(int j=i; j<vec->size();j++){
			if((*vec)[j].center.y > (*vec)[i].center.y){
				squares_t temp = (*vec)[i];
				(*vec)[i] = (*vec)[j];
				(*vec)[j] = (*vec)[i];
			}
		}
	}
}

//take a vector and make it a squares_t pointer
void vectorToSquares_t(std::vector<squares_t> * vec, squares_t * sqr){
	squares_t * temp = sqr;
	*temp = (*vec)[0];
	for(int i=1; i<vec->size(); i++) {
		temp->next = new squares_t;
		temp = temp->next;
		*temp = (*vec)[i];
	}
}